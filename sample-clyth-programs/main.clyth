struct TestObj {
   int64 index
   int64 max
   string payload,
   function[] callback_functions.
   int64 _counter // this is private/hidden except to methods inside this struct, indicated by the '_' in the beginning. It's enforced at the compiler-level but at runtime this field is accessible since it's part of the struct
   
   // DEFAULT methods that must exist and don't need to specify the return-type - as they're automatically returning a TestObj instance - as this will be compiled out as if you wrote a separate struct and had functions in a specific C header/code file to use for that particular struct-type with a 'self' or struct reference. This resolves the grievance of C++ classes where in the separate implementation file you'd have to scope/namespace your class that you're defining the method bodies for - which is annoying and cumbersome. This way, it's lean and elegant in a single file and specific methods are IMPLIED by the compiler.
   constructor() {}
   destructor() {}
   clone() {}
   deep_clone() {}

   // Any additional functions/methods are just written like regular functions too but return types must be specified now.

   // This below is an example of using structs for parameters and a good use of showing a function pointer/reference is supposed to be passed into this method to call back to. The structure of the function is hidden and it's intentional, so you have to document the function structure(s) being called-back to as a comment above the function/method for other developers to know how to use your callback.
   bool register_callback(function callback_function, optional args{}) {
      if (this.index > 1000) {
         this.callback_functions.append(callback_function, args) // Second field is always required for the args needed for this function. You don't have to specify them if no args are needed as an empty struct/null will be inserted instead.
      } else {
         this.callback_functions.append(callback_function) // no args;
      }
      return true
   }
   // If you want to implement an interface - simply include it here:
  include(interface_drawable, interface_collection, interface_equivalent)
  bool draw() {}
  
  // Like Java - an iterator for has_next and current iterator call to get next instance of TestObj for very niche cases where you are making something that Clyth doesn't provide you for your looping schemes. Essentially, loops will call into your has_next and iter calls to check if there is a next-iteration for another element before calling iter to retrieve that next element and incrementing internally. The counter for iter will be included by the compiler from the interface import statement, that way you only need to worry about the function calls and not the primitives or fields associated with the interface. Perhaps IDE's could add them here for more convenience and developer ease-of-use.
  bool has_next() {}
  TestObj iter() {}
  
  // With more IDE and compiler tooling - this can simply be added into this struct for convenience. Ultimately - this could be stored as type-info for reflection at runtime for things like - TestObj my_instance = new TestObj(0, 1, "string"); bool test = my_instance is interface_drawable; // the interface tags in the struct would be compared to this drawable as a string for true or false at runtime or even at compile-time if the struct is visible to the compiler in src-form.
}

bool callback_function (TestObj instance) {
   if instance is drawable {
      printf("Drawable instance - can draw component!")
      return true
   }
      return false
}

int main (string args[]) {
   TestObj myObj = new TestObj({0, 100, "something"})
   callback_function(myObj)
   callback_function(myObj.clone())
   myObj.index = 100000;
   myObj.register_callback(callback_function, { instance: myObj.clone() }) // an optional args list in JSON/struct form.
   return 0
}
